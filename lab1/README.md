# README
This zip file includes the program source file, a CONFIG file, a log file, a
statistics file, and a runs file. This program, called a Discrete Event
Simulator, is meant to simulate how processes move through a computer system. 
It has four components and five queues. The components are not actually present
in the program, they are represented by a time skip in the system time. There
are four FIFO queues represented by integer arrays, and one priority queue
represented by an array of structures. The priority queue is outside the
"computer system", and it is responsible for feeding new processes into the
system, as well as moving the processes around following the correct paths. It
does this using events. Each of the structures in the priority queue represents
an event, and contains a time, an event type, and a process ID. There are
eleven event types in total, used to designate where a process will be heading
to next. There is an event handler function for each type that will take the
necessary actions based on the event type, for example changing its type so the
process can continue on its path, or creating a new event so the flow of
processes entering the system does not end until FIN_TIME is reached. These
event handlers are called using a switch case. Events are removed from the
priority queue by time, so the event with the lowest time is removed first.
In order to ensure that the event at the front of the priority queue has 
the lowest time, the queue is sorted every time a new event is added. When a
new process is created, all that is printed to the log file is a message
that it has entered the system. In order for this to happen, a new event is
created.  This event's type is PROCESS_ARRIVAL, and its time is set to the
current system time, or the time of the previous event, plus a generated
random number between ARRIVE_MIN and ARRIVE_MAX. It is given a unique process
ID generated by a function that returns an integer given by its static 
increasing count. Once this event reaches the front of the priority queue, it
is removed from the queue and sent through the switch case to determine which
event handler it must be sent to. Finally, it is processed in the correct
event handler function and and this cycle continues with the next event in
the priority queue. I can see benefits for both linked lists and arrays in this
project, but because I have never used linked lists in C before and felt more
comfortable using arrays I decided to go with that. One change I made to the
original directions was using an integer between 1 and 100 for the probability
values, instead of using a double. I did this because I felt it would be easier
to just use one random number generating function that would always return an
integer. In order to make the project more manageable, I created all the 
structures I would need first. Then I tested them to make sure all the
groundwork would hold up for when I added the event handlers. While testing the
event handlers, I only tested for about 100-500 time units to make the output
readable. After adding everything, I tested several different inputs to make
sure everything would work properly even if there were thousands of processes
and events.